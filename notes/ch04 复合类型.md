## 第四章 复合类型

### 4.1 数组

* 数组是一种数据格式，能够储存多个同类型的值：

  * 例如，数组可以储存60个int类型的值。
  * 创建数组时，需要如下声明：
    * 储存在每个元素中的值的类型；
    * 数组名；
    * 数组中的元素。
  * 声明数组的通用格式：
    * *typeName* arratName[arraySize];
    * short months[12];
    * 这里要`注意`：最后一个元素的索引比数组长度小1：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/28300dd4-694f-48a2-850b-57f1af0da040)


* 例程：

  * ``` c++
    // arrayone.cpp -- small arrays of integers
    #include <iostream>
    int main() {
    	using namespace std;
    	int yams[3];
    	yams[0] = 7;
    	yams[1] = 8;
    	yams[2] = 6;
    
    	int yamcosts[3] = {20, 30, 5 };
    
    	cout << "Total yams = ";
    	cout << yams[0] + yams[1] + yams[2] << endl;
    	cout << "The package with " << yams[1] << " yams costs ";
    	cout << yamcosts[1] << " cents per yam.\n";
    	
    	int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    	total = total + yams[2] * yamcosts[2];
    	cout << "The total yam expense is " << total << " cents.\n";
    
    	cout << "\nSize of yams array = " << sizeof yams;
    	cout << " bytes.\n";
    	cout << "Size of one element = " << sizeof yams[0];
    	cout << " bytes.\n";
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Total yams = 21
    The package with 8 yams costs 30 cents per yam.
    The total yam expense is 410 cents.
    
    Size of yams array = 12 bytes.
    Size of one element = 4 bytes.
    ```

#### 4.1.1 程序说明

* 申明数组时，可以给数组元素赋值：

  * ``` c++
    int yamcosts[3] = {20, 30, 5 };
    ```

* sizeof运算符返回类型或数据对象的长度（单位为字节）：

  * 如果将 sizeof 用于数组名，得到的将是整个数组中的字节数。
  * 但如果将 sizeof 用于数组元素，则得到的将是元素的长度(单位为字节)。

#### 4.1.2 数组的初始化规则

* 只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：

  * ``` c++
    int cards[4] = {3, 6, 8, 10};  //okay
    int hand[4];			      //okay
    hand[4] = {5, 6, 7, 9};		  //not allowed
    hand = cards;  				  //not allowed
    ```

* `但是`，可以使用下标分别给数组中的元素赋值。

* 初始化数组时，提供的值可以少于数组的元素数目。

* 如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。因此，将数组中所有的元素都初始化为0非常简单：

  * 只要显式地将第一个元素初始化为0,然后让编译器将其他元素都初始化为0即可:

  * ``` c++
    long cards[400] = {0};  //okay
    ```

* 如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素都被设置为0。

* 如果初始化数组时方括号内([])为空，C++编译器将计算元素个数。例如，对于下面的声明:

  * ``` c++
    int cards[] = {3, 6, 8, 10};  //okay
    ```



#### 4.1.3 C++11数组初始化方法

* C++11将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。

* 新增功能：

  * 1、初始化数组时，可省略等号（=）：

    * ``` c++
      double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};
      ```

  * 2、可不在大括号内包含任何东西，这将把所有元素都设置为`零`：

    * ``` c++
      unsigned int counts[10] = {};
      float balances[100] {};
      ```

  * 3、列表初始化禁止缩窄转换,：

    * ``` c++
      long plifs[] = {25, 92, 3.0};  //将浮点数转换为整型是缩窄操作not allowed
      char slifs[4] = {'h', 'i', 1122011, '\0'};  //1122011超出了char变量的取值范围not allowed
      char tlifs[4] = {'h', 'i', 112, '\0'};  //因为虽然112是一个int值，但它在 char变量的取取值范围allowed
      ```



### 4.2 字符串

* C-风格字符串（需要又空字符（\0）结尾）-冗长乏味：

  * ```c++
    char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};
    ```

* 字符串常量/字符串字面值（更好的将字符数组初始化为字符串的方法）：

  * ``` c++
    char bird[11] = "Mr. Cheeps";
    char fish[] = "Bubbles";
    ```

  * 用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。

* `注意`：字符串常量（使用双引号）不能与字符常量（使用单引号）互换。

  * 字符串常量（使用双引号）是字符串编码的简写表示：

    * ``` c++
      char shirt_size = 'S';//将83赋给shirt_size
      ```

  * "S"际上表示的是字符串所在的内存地址。因此下面的语句试图将一个内存地址赋给shirt_size:

    * ``` c++
      char shirt_size = "S";
      ```



#### 4.2.1 拼接字符串常量

* C++允许凭借字符串字面值，即将两个用引号括起的字符串合并为一个：

  * ``` c++
    cout << "I'd gibe my right arm to be" " a great violinist.\n";
    cout << "I'd gibe my right arm to be a great violinist.\n";
    cout << "I'd gibe my right ar"
        "m to be a great violinist.\n";
    ```

  * `注意`：拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后面。

  * 第一个字符串中的\0字符将被第二个字符串的第一个字符取代。



#### 4.2.2 在数组中使用字符串

* 将字符串储存到数组中的常用两大方法：

  * 1、将数组初始化为字符串常量。
  * 2、将键盘或文件输入读入到数组中。

* 例程：

  * ``` c++
    // strings.cpp -- storing strings in an array
    #include <iostream>
    #include <cstring>
    
    int main() {
    	using namespace std;
    	const int Size = 15;
    	char name1[Size];
    	char name2[Size] = "C++owboy";
    
    	cout << "Howdy! I'm " << name2;
    	cout << "! What's your name?\n";
    	cin >> name1;
    	cout << "Well, " << name1 << ", your name has ";
    	cout << strlen(name1) << " letters and is stored\n";
    	cout << "Your initial is " << name1[0] << ".\n";
    	name2[3] = '\0';
    	cout << "Here are the first 3 characters of my name: ";
    	cout << name2 << endl;
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Howdy! I'm C++owboy! What's your name?
    Basicman
    Well, Basicman, your name has 8 letters and is stored
    Your initial is B.
    Here are the first 3 characters of my name: C++
    ```

  * sizeof运算符能够指出整个数组的长度；

  * 而strlen()函数能够返回储存在数组中的字符串长度（多少个可见字符，非空字符），而不是数组本身的长度（15字节）。

  * 将name2[3]设置为空字符，使得输出字符串在第三个字符后即结束。

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/a0c71cfc-6909-4842-af1b-18abf9541cec)




#### 4.2.3 字符串输入

* cin使用空白来确定字符串的结束位置，因此cin在获取字符数组输入时只读取一个单词。

* 例程：

  * ``` c++
    // instr1.cpp -- reading more than one string
    #include <iostream>
    
    int main() {
    	using namespace std;
    
    	const int ArSize = 20;
    	char name[ArSize];
    	char dessert[ArSize];
    
    	cout << "Enter your name:\n";
    	cin >> name;
    	cout << "Enter your favorite dessert:\n";
    	cin >> dessert;
    	cout << "I have some delicious " << dessert;
    	cout << " for you, " << name << ".\n";
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Enter your name:
    Alistair Dreeb
    Enter your favorite dessert:
    I have some delicious Dreeb for you, Alistair.
    ```

* 解决办法：下届内容：采用面向行而不是面向单词的方法：



#### 4.2.4 每次读取一行字符串输入

* getline()：读取一行输入，丢弃换行符；

* get()：读取一行输入，将换行符保留在输入序列中。

* 1、getline()：

  * 调用方法：

    * cin.getline(name, 20);
    * 该函数有两个参数：
      * 第一个参数是用来存储输入行的数组的名称；
      * 第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的`空字符`。
      * getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

  * 例程：

    * ``` c++
      // instr2.cpp -- reading more than one word with getline
      #include <iostream>
      
      int main() {
      	using namespace std;
      
      	const int ArSize = 20;
      	char name[ArSize];
      	char dessert[ArSize];
      
      	cout << "Enter your name:\n";
      	cin.getline(name, ArSize);
      	cout << "Enter your favorite dessert:\n";
      	cin.getline(dessert, ArSize);
      	cout << "I have some delicious " << dessert;
      	cout << " for you, " << name << ".\n";
      	return 0;
      }
      ```

  * 结果：

    * ``` c++
      Enter your name:
      Dirk Hammernose
      Enter your favorite dessert:
      Radish Torte
      I have some delicious Radish Torte for you, Dirk Hammernose.
      ```

* 2、get()：

  * 由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。

  * 因此get()认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get()将不能跨过该换行符：

    * ``` c++ 
      cin.get(name, ArSize);
      cin.get(dessert, ArSize); //problem
      ```

  * 解决办法：

    * 1、使用不带任何参数的cin.get()调用：

      * ``` c++
        cin.get(name, ArSize);
        cin.get();
        cin.get(dessert, ArSize); 
        ```

    * 2、使用get()方式将两个类成员函数拼接：

      * ```c++
        cin.get(name, ArSize).get();
        cin.getline(name1, ArSize).getline(name2, ArSize);
        ```

  * 例程：

    * ``` c++
      // instr3.cpp -- reading more than one word with get() & get()
      #include <iostream>
      
      int main() {
      	using namespace std;
      
      	const int ArSize = 20;
      	char name[ArSize];
      	char dessert[ArSize];
      
      	cout << "Enter your name:\n";
      	cin.get(name, ArSize).get();
      	cout << "Enter your favorite dessert:\n";
      	cin.get(dessert, ArSize).get();
      	cout << "I have some delicious " << dessert;
      	cout << " for you, " << name << ".\n";
      	return 0;
      }
      ```

  * 结果：

    * ``` c++\
      Enter your name:
      Mai Parfait
      Enter your favorite dessert:
      Chocolate Mousse
      I have some delicious Chocolate Mousse for you, Mai Parfait.
      ```

  * 结论：getline()使用起来简单一些，但get()使得检查错误更简单些。

* 3、空行和其他问题：
  * 当get()读取空行后将设置失效位。即接下来的输入将被阻断，但可以用下面的命令来恢复输入：
    * cin.clear();
  * 输入字符串可能比分配的空间长：
    * getline()和get()将把余下的字符留在输入队列中；
    * 而getline()还会设置实效位，并关闭后面的输入。



#### 4.2.5 混合输入字符串和数字

* 例程：

  * ``` c++
    // numstr.cpp -- following number input with line input
    #include <iostream>
    
    int main() {
    	using namespace std;
    	cout << "What year was your house built?\n";
    	int year;
    	cin >> year;
    	cin.get();
    	cout << "What is its street address?\n";
    	char address[80];
    	cin.getline(address, 80);
    	cout << "Year built: " << year << endl;
    	cout << "Address: " << address << endl;
    	cout << "Done!\n";
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    What year was your house built?
    2000
    What is its street address?
    Beihang University
    Year built: 2000
    Address: Beihang University
    Done!
    ```

  * 如果不加cin.get()；代码就会把输入完数字后的回车转换为换行符留在输入队列中，当cin.getline()进行时，会认为换行符是空行，将空字符传给目标数组。



### 4.3 string类简介

* 可以用string类型的变量来储存字符串，而不是字符数组。

* string类更方便，同时提供了将字符串作为一种数据类型的表示方法。

* 例程：

  * ``` c++
    // strtype1.cpp -- using the C++ string class
    #include <iostream>
    #include <string>
    
    int main() {
    	using namespace std;
    	char charr1[20];
    	char charr2[20] = "jaguar";
    	string str1;
    	string str2 = "panther";
    
    	cout << "Enter a kind of feline: ";
    	cin >> charr1;
    	cout << "Enter another kind of feline: ";
    	cin >> str1;
    	
    	cout << "Here are some kind of felines:\n";
    	cout << charr1 << " " << charr2 << " "
    		 << str1 << " " << str2 << endl;
    	cout << "The third letter in " << charr2 << " is "
    		 << charr2[2] << endl;
    	cout << "The third letter in " << str2 << " is "
    		<< str2[2] << endl;
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Enter a kind of feline: ocelot
    Enter another kind of feline: tiger
    Here are some kind of felines:
    ocelot jaguar tiger panther
    The third letter in jaguar is g
    The third letter in panther is n
    ```

  * 使用string对象的方式与使用字符数组基本相同；

  * 主要却别在于：

    * 可以将sting对象声明为简单变量，而不是数组：
      * string str1;
      * string str2 =  "panther";
    * 类设计能够让程序自动处理string的大小，使得与使用数组相比，更方便也更安全。



### 4.3 string类简介

* 可以用string类型的变量来储存字符串，而不是字符数组。

* string类更方便，同时提供了将字符串作为一种数据类型的表示方法。

* 例程：

  * ``` c++
    // strtype1.cpp -- using the C++ string class
    #include <iostream>
    #include <string>
    
    int main() {
    	using namespace std;
    	char charr1[20];
    	char charr2[20] = "jaguar";
    	string str1;
    	string str2 = "panther";
    
    	cout << "Enter a kind of feline: ";
    	cin >> charr1;
    	cout << "Enter another kind of feline: ";
    	cin >> str1;
    	
    	cout << "Here are some kind of felines:\n";
    	cout << charr1 << " " << charr2 << " "
    		 << str1 << " " << str2 << endl;
    	cout << "The third letter in " << charr2 << " is "
    		 << charr2[2] << endl;
    	cout << "The third letter in " << str2 << " is "
    		<< str2[2] << endl;
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Enter a kind of feline: ocelot
    Enter another kind of feline: tiger
    Here are some kind of felines:
    ocelot jaguar tiger panther
    The third letter in jaguar is g
    The third letter in panther is n
    ```

  * 使用string对象的方式与使用字符数组基本相同；

  * 主要却别在于：

    * 可以将sting对象声明为简单变量，而不是数组：
      * string str1;
      * string str2 =  "panther";
    * 类设计能够让程序自动处理string的大小，使得与使用数组相比，更方便也更安全。



#### 4.3.1 C++11 字符串初始化

``` c++
char first_data[] = {"Le Chapon Dodu"};
char second_data[] {"Le Chapon Dodu"};
char third_data = {"Le Chapon Dodu"};
char fourth_data {"Le Chapon Dodu"};
```



#### 4.3.2 赋值、拼接和附加

* 1、赋值：

  * 可以将一个string对象赋给另一个string对象，但数组不能赋给另一个数组：

  * ```C++
    char charr1[20];
    char cahrr2[20] = "jaguar";
    string str1;
    string str2 = "panther";
    charr1 = charr2;//x INVALID
    str1 = str2;//VALID
    ```

* 2、拼接和附加：

  * 可以使用运算符+将两个string对象合并

  * 也可以用+=将字符串附加到string对象的末尾

  * ``` c++
    string str3;
    str3 = str1 + str2;
    str1 += str2;
    ```

* 例程：

  * ``` c++
    // strtype2.cpp -- assigning, adding, and appending
    #include <iostream>
    #include <string>
    int main() {
    	using namespace std;
    	string s1 = "penguin";
    	string s2, s3;
    
    	cout << "You can assign one string object to another: s2 = s1\n";
    	s2 = s1;
    	cout << "s1: " << s1 << ", s2: " << s2 << endl;
    	cout << "You can assign a C-style sring to a string object.\n";
    	cout << "s2 = \"buzzard\"\n";
    	s2 = "buzzard";
    	cout << "s2: " << s2 << endl;
    	cout << "You can concatenate strings: s3 = s1 + s2\n";
    	s3 = s1 + s2;
    	cout << "s3: " << s3 << endl;
    	cout << "You can cappend strings.\n";
    	s1 += s2;
    	cout << "s1 += s2 yields s1 = " << s1 << endl;
    	s2 += " for a day";
    	cout << "s2 += \" for a day\" yields s2 = " << s2 << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    You can assign one string object to another: s2 = s1
    s1: penguin, s2: penguin
    You can assign a C-style sring to a string object.
    s2 = "buzzard"
    s2: buzzard
    You can concatenate strings: s3 = s1 + s2
    s3: penguinbuzzard
    You can cappend strings.
    s1 += s2 yields s1 = penguinbuzzard
    s2 += " for a day" yields s2 = buzzard for a day
    ```



#### 4.3.3 string 类的其他类型

* 头文件cstring提供了给字符串赋值等工作的函数：

  * strcpy()将字符串赋值到字符数组中；
  * strcat()将字符串附加到字符数组末尾；

* 例程：

  * ``` c++
    // strtype3.cpp -- more string class features
    #define _CRT_SECURE_NO_WARNINGS
    #include <iostream>
    #include <string>
    #include <cstring>
    int main() {
    	using namespace std;
    	char charr1[20];
    	char charr2[20] = "jaguar";
    	string str1;
    	string str2 = "panther";
    
    	str1 = str2;
    	strcpy(charr1, charr2);
    
    	str1 += " paste";
    	strcat(charr1, " juice");
    
    	int len1 = str1.size();
    	int len2 = strlen(charr1);
    
    	cout << "The string " << str1 << " contains "
    		 << len1 << " characters.\n";
    	cout << "The string " << charr1 << " contains "
    		<< len2 << " characters.\n";
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    The string panther paste contains 13 characters.
    The string jaguar juice contains 12 characters.
    ```

  * 使用字符数组时，总是存在目标数目过小，无法储存指定信息的危险：

    * strcat()视图将全部字符复制到目标数组中，浙江覆盖相邻的内存，可能导致程序终止。
    * 而string类具有自动调整大小的功能。

  * 确定字符串中字符数的方法：

    * ``` c++
      int len1 = str1.size();
      int len2 = strlen(charr1);
      ```

    * 而C++ string 类对象使用对象名和句点运算符来指出要使用哪个字符串。



#### 4.3.4 stringl 类 I/O

* 例程：

  * ``` c++
    // strtype4.cpp -- line input
    #include <iostream>
    #include <string>
    #include <cstring>
    
    int main() {
    	using namespace std;
    	char charr[20];
    	string str;
    
    	cout << "Length of string in charr before input: "
    		 << strlen(charr) << endl;
    	cout << "Length of string in str before input: "
    	   	 << str.size() << endl;
    	cout << "Enter a line of text:\n";
    	cin.getline(charr, 20);
    	cout << "You entered: " << charr << endl;
    	cout << "Enter another line of text:\n";
    	getline(cin, str);
    	cout << "You entered: " << str << endl;
    	cout << "Length of string in charr after input: "
    	 	 << strlen(charr) << endl;
    	cout << "Length of string in str after input: "
    		 << str.size() << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Length of string in charr before input: 31
    Length of string in str before input: 0
    Enter a line of text:
    peanut butter
    You entered: peanut butter
    Enter another line of text:
    blueberry jam
    You entered: blueberry jam
    Length of string in charr after input: 13
    Length of string in str after input: 13
    ```

  * strlen()函数对于未被初始化的数据，第一个空字符出现的位置是随机的，因此得到的数组长度很可能与申明不同。

  * str.size()能够读取未被初始化的string对象长度，该长度自动这是为0；

  * cin.getline(charr, 20)：

    * getline是istream类的一个类方法；
    * cin是istream对象
    * （  ，）中第一个是目标数组，第二个是参数长度

  * getline(cin, str)：

    * 这里getline()不是类方法
    * 它将cin作为参数，指出到哪里去查找输入



#### 4.3.5 其他形式的字符串字面值

|   类型   | 前缀 |                  备注                   |
| :------: | :--: | :-------------------------------------: |
| wchar_t  |  L   | wchar_t title[] = L"Chief Astrogator";  |
| char16_t |  u   | char16_t name [] = u"Felonia Ripova" ;  |
| char32_t |  U   | char32_t car [] =U"Humber Super Snipe"; |
|   raw    |  R   |     cout << R"(xxx "xx" "\n"xxx)";      |

* 院士字符串语法语法允许再表示字符串开头的`"`和`(`之间添加其他字符

  * 使用R"+* (标识原始字符串的开头时，必须使用)+*标识原始字符串的

  * ```
    cout << R"+*("(Who wouldn't?)", she whispered.)+*" << endl;
    //out:"(Who wouldn't?)", she whispered.
    ```



### 4.4 结构简介

* 结构是一种比数组更灵活的数据格式，因为同一个结构可以储存多种类型的数据，这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。

* 结构的创建（2步）：

  * 1、定义结构描述：描述并标记了能够储存在结构中的各种数据类型；

    * ``` c++
      struct inflatable
      {
          char name[20];
          float volume;
          double price;
      };
      ```

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/d00c2ef2-ab79-4bff-8b76-c48aede396d6)


  * 2、按描述创建结构变量:

    * ``` c++
      inflatable hat;
      inflatable woopie_cushion;
      inflatable mainframe;
      ```

    * C++中创建结构变量可以省略struct。

    * 之后便可以使用hat.volume进行访问各个成员，hat是一个结构，而hat.volume是一个char变量。



#### 4.4.1 在程序中使用结构

* 例程：

  * ``` c++
    // structur.cpp -- a simple structure
    #include <iostream>
    struct inflatable {
    	char name[20];
    	float volume;
    	double price;
    };
    
    int main() {
    	using namespace std;
    
    	inflatable guest = {
    		"Glorious Gloria",
    		1.88,
    		29.99
    	};
    
    	inflatable pal = {
    		"Audacious Arthur",
    		3.12,
    		32.99
    	};
    
    	cout << "Expand your gest list with " << guest.name;
    	cout << " and " << pal.name << "!\n";
    	cout << "You can have both for $";
    	cout << guest.price + pal.price << "!\n";
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Expand your gest list with Glorious Gloria and Audacious Arthur!
    You can have both for $62.98!
    ```

  * 结构声明这里采用外部声明，声明有两种方式，通常采用外部声明。

  * 变量也可以在函数内部和外部定义，这里提倡使用外部结构声明，内部变量定义。



#### 4.4.2 C++ 结构初始化

* 与数组一样，C++也支持将列表初始化用于结构，且等号是可选的：

  * ``` c++
    inflatable duck {"Daphne", 0.12, 9
                    98};
    ```

* 其次，如果大括号内未包含任何东西，各个成员都将被设置为零：

  * ```c++
    inflatable mayor {};
    ```

* 最后，不允许缩窄转换。



#### 4.4.3 结构可以将string类作为成员

* 只要您使用的编译器支持对以string对象作为成员的结构进行初始化，就可以。

* ``` c++
  #include <string>
  struct inflatable{
    std::string name;
    float volume;
    double price;
  };
  ```



#### 4.4.4 其他结构属性

* 1、可以将结构作为参数传递给函数，也可以让函数返回一个结构；

* 2、还可以使用赋值运算符（=）将结构赋给另一种类型的结构。

* 例程：

  * ```c++
    // assign_st -- assigning structures
    #include <iostream>
    struct inflatable{
    	char name[20];
    	float volume;
    	double price;
    };
    
    int main() {
    	using namespace std;
    	inflatable bouquet = {
    		"sunflowers",
    		0.20,
    		12.49
    	};
    
    	inflatable choice;
    	cout << "bouquet: " << bouquet.name << " for $";
    	cout << bouquet.price << endl;
    
    	choice = bouquet;
    	cout << "choice: " << choice.name << " for $";
    	cout << choice.price << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    bouquet: sunflowers for $12.49
    choice: sunflowersfor $12.49
    ```

  * 可以同时完成定义结构和创建结构变量的工作：

    * ``` c++
      struct perks
      {
          int key_number;
          char car[12];
      } mr_smith, ms_jones;
      
      //甚至可以初始化：
      struct perks
      {
          int key_number;
          char car[12];
      } mr_glitz = 
      {
          7,
          "Packard"
      };
      ```



#### 4.4.5 结构数组

* 可以创建元素为结构的数组：

  * ``` c++
    inflatable gifs[100];
    ```

  * 这样就就可以理解为创建了一批人，他们手上对应不同的物品

  * 即：gifts是一个inflatable数组，其中每个元素gifts[0]、gifts[1]都是inflatable对象，可以这样用：

    * gifts[0].volume;
    * gifts[99].price;

* 结构数组初始化：

  * ``` c++
    inflatable guests[2] = {
        {"Bambi", 0.5, 21.99},
        {"Godzilla", 2000, 565.99}
    };
    ```

* 例程：

  * ```c++
    // arrstruc.cpp -- an arry of structures
    #include <iostream>
    struct inflatable {
    	char name[20];
    	float volume;
    	double price;
    };
    
    int main() {
    	using namespace std;
    	inflatable guests[2] = {
    		{"Bambi", 0.5, 21.99},
    		{"Godzilla", 2000, 565.99}
    	};
    
    	cout << "The guests " << guests[0].name << " and " << guests[1].name
    		<< "\nhave a combined volume of "
    		<< guests[0].volume + guests[1].volume << " cubic feet.\n";
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    The guests Bambi and Godzilla
    have a combined volume of 2000.5 cubic feet.
    ```



#### 4.4.6 结构中的位字段

* C++也允许指定占用特定位数的结构成员：

* 字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，指定了使用的位数。

* 例程：

  * ``` c++
    struct torgle_register{
        unsigned int SN : 4;
        unsigned int : 4;
        bool goodIn : 1;
        bool goodTorgle : 1;
    }
    ```



### 4.5 共用体

* 共用体和结构体有相似之处，能够储存不同的数据类型，但是`只能同时储存其中的一种类型`。
* 由于共用体每次只能储存一个值，因此共用体的长度为其最大成员的长度。
* 用途之一：当数据项使用两种或更多种格式（但不会同时使用时），可以节省空间：
  * 例如管理一个小商品目录，其中有一些商品的ID为整数，而另一些ID为字符串。见P95，共用体用在了结构的成员当中，因此就说明了共用体是一种数据格式。
  * 共用体常用于(但并非只能用于）节省内存。当前，系统的内存多达数GB甚至数TB，好像没有必要节省内存，但并非所有的C++程序都是为这样的系统编写的。C++还用于嵌入式系统编程，如控制烤箱、MP3播放器或火星漫步者的处理器。对这些应用程序来说，内存可能非常宝贵。另外，共用体常用于操作系统数据结构或硬件数据结构。



### 4.6 枚举

* enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还可以定义新类型，但必须按严格的限制进行：

  * ``` c++
    enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
    ```

  * 让 spectrum成为新类型的名称；spectrum被称为枚举(enumeration)，就像struct变量被称为结构一样。

  * 将red、 orange、yellow等作为符号常量,它们对应整数值0~7。这些常量叫作枚举量( enumerator)。

  * 可以用枚举名来声明这种类型的变量：

    * ``` c++ 
      spectrum band;
      ```



#### 4.6.1 设置枚举量的值

* 可以使用赋值运算符来显式地设置枚举量的值：

  * ```c++
    enum bits{one = 1, two = 2, four = 4, eight = 8};
    ```

* 指定的值必须为整数。也可以只显式地定义其中一些枚举量的值：

  * ``` c++
    enum bigstep{first, second = 100, third};
    ```

  * 这里，first在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。即third=101。

* 可以创建多个值相同的枚举量：

  * ```c++
    enum {zero, null = 0, one, numero_uno = 1};
    ```



#### 4.6.2 枚举的取值范围

* 见P97



### 4.7 指针和自由存储空间

* 指针是一个变量，其储存的式值得地址，而不是值得本身。

* 对变量应用地址运算符即可找到常规变量得地址：

  * 例程：

    * ``` c++
      // address.cpp -- using the & operator to find addresses
      #include <iostream>
      
      int main() {
      	using namespace std;
      	int donuts = 6;
      	double cups = 4.5;
      
      	cout << "donuts value = " << donuts;
      	cout << " and donuts address = " << &donuts << endl;
      	cout << "cups value = " << cups;
      	cout << " and cups address = " << &cups << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ``` c++
      donuts value = 6 and donuts address = 00EFF6F4
      cups value = 4.5 and cups address = 00EFF6E4
      ```

* 指针名表示的是地址。*运算符可以得到该地址存储的值：

  * 例程：

    * ```c++
      // pointer.cpp -- our first pointer variable
      #include <iostream>
      int main() {
      	using namespace std;
      	int updates = 6;
      	int * p_updates;
      	p_updates = &updates;
      
      	cout << "Values: updates = " << updates;
      	cout << ", *p_updates = " << *p_updates << endl;
      
      	cout << "Addresses: &updates = " << &updates;
      	cout << ", p_updates = " << p_updates << endl;
      
      	*p_updates = *p_updates + 1;
      	cout << "Now updates = " << updates << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      Values: updates = 6, *p_updates = 6
      Addresses: &updates = 00C4F884, p_updates = 00C4F884
      Now updates = 7
      ```

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/5b4687f0-f0ae-476a-9e97-bcfd28e291b2)




#### 4.7.1 声明和初始化指针

* 指针声明必须指定指针指向的数据类型：
  * int * p_updates;
  * p_updates的类型是指向int的指针

* 对于每个指针变量名，都需要使用一个*：

  * int* p1, p2;
  * 该声明创建了一个指针（p1）和一个int变量（p2）

* 例程：

  * ``` c++
    //int_ptr.cpp -- initialize a pointer
    #include <iostream>
    int main() {
    	using namespace std;
    	int higgens = 5;
    	int* pt = &higgens;
    
    	cout << "Value of higgens = " << higgens
    		 << "; Address of higgens = " << &higgens << endl;
    	cout << "Value of *pt = " << *pt
    		 << "; Address of pt = " << pt << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Value of higgens = 5; Address of higgens = 008FF954
    Value of *pt = 5; Address of pt = 008FF954
    ```

  * 程序将pi（而不是*pi）初始化为higgens的地址：

    * ``` c++
      int* pt = &higgens;
      ```

    * 等价于：

    * ``` c++
      	int * pt;
      	pt = &higgens;
      ```



#### 4.7.2 指针的危险

* 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向数据内存。



#### 4.7.3 指针和数字

* 指针不是数字，不能简单地将整数赋值给指针，需要强制转换：

* ``` c++
  int* pt;
  pt - (int *) 0xB8000000;
  ```



#### 4.7.4 使用new来分配内存

* ```c++
  int* pn = new int;
  ```

  * new int 告诉程序，需要适合存储int的内存，new运算符根据类型来确定需要多少字节的内存。
  * 然后找到这样的内存，并返回该内存块的地址。

* 为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下:

  * ```c++
    typeName* pointer_name = new typeName;
    ```

* 例程：

  * ```c++
    // use_new.cpp -- using the new operator
    #include <iostream>
    
    int main() {
    	using namespace std;
    	int nights = 1001;
    	int* pt = new int;
    	*pt = 1001;
    	
    	cout << "nights value = ";
    	cout << nights << ": location " << &nights << endl;
    	cout << "int ";
    	cout << "value = " << *pt << ": location = " << pt << endl;
    	double* pd = new double;
    	*pd = 10000001.0;
    
    	cout << "double ";
    	cout << "value = " << *pd << ": location = " << pd << endl;
    	cout << "location of pointer pd: " << &pd << endl;
    	cout << "size of pt = " << sizeof(pt);
    	cout << ": size of *pt = " << sizeof(*pt) << endl;
    	cout << "size of pd = " << sizeof(pd);
    	cout << ": size of *pd = " << sizeof(*pd) << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    nights value = 1001: location 00B9FC44
    int value = 1001: location = 01220B98
    double value = 1e+07: location = 01221B80
    location of pointer pd: 00B9FC2C
    size of pt = 4: size of *pt = 4
    size of pd = 4: size of *pd = 8
    ```



#### 4.7.5 使用delete释放内存

* 当需要内存时，可以使用new来请求；

* 当使用完内存后，需要将其归还给内存池时，可以使用delete运算符。

  * ``` c++
    int* ps = new int;
    ...
    delete ps;
    ```

  * 这将释放ps指向的内存，但不会删除指针ps 本身。例如，可以将ps重新指向另一个新分配的内存块。

* `注意`：详情见P104

  * 一定要配对地使用new和delete；
  * 不要尝试释放已经释放地内存块；
  * 不能使用delete来释放声明变量所获得的内存。



#### 4.7.6 使用new来创建动态数组

* 应用于大型数据，使用new时，如果在运行阶段需要数组，则创建它。

* 1、使用new 创建动态数组：

  * 只要将数组的元素类型和元素数目告诉new即可：

    * ``` C++
      int* psome = new int [10];
      ```

    * new运算符返回第一个元素的地址。

  * 当使用完new分配的内存块时，应使用delete释放他们，对`对应`的释放方式为：

    * ``` c++
      delete [] psome;
      ```

  * 总结，使用new和delete时，应遵守如下规则：

    * 不要使用delete来释放不是new分配的内存。
    * 不要使用delete释放同一个内存块两次。
    * 如果使用new []为数组分配内存，则应使用delete []来释放。
    * 如果使用new []为一个实体分配内存，则应使用delete（没有方括号）来释放。
    * 对空指针应用delete是安全的。

  * 不能使用sizeof运算符来确定动态分配的数组包含的字节数。

  * 为数组分配内存的通用格式：

    * ``` c++
      type_name * pointer_name = new type_name [num_elements]
      ```

* 2、使用动态数组

  * ```c++
    int* psome = new int [10];
    ```

  * 只要把指针当作数组名使用即可：

    * 第一个元素psome[0]，第二个元素psome[1]

  * 例程：

    * ``` c++
      // arraynew.cpp -- using the new operator for arrays
      #include <iostream>
      int main() {
      	using namespace std;
      	double* p3 = new double[3];
      	p3[0] = 0.2;
      	p3[1] = 0.5;
      	p3[2] = 0.8;
      	cout << "p3[1] is " << p3[1] << ".\n";
      	p3 = p3 + 1;
      	cout << "Now p3[0] is " << p3[0] << " and ";
      	cout << "p3[1] is " << p3[1] << ".\n";
      	p3 = p3 - 1;
      	delete [] p3;
      	
      	return 0;
      }
      ```

  * 结果：

    * ``` c++
      p3[1] is 0.5.
      Now p3[0] is 0.5 and p3[1] is 0.8.
      ```

  * 相邻的 int 地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。详情见P106
